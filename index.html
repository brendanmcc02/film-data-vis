<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>filmDataVis</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>

<body>
  <canvas id="myChart" width="200" height="100"></canvas>
  <script>

    main();

    async function main() {
      const bottom3Genres = await getBottom3Genres();
      const bottom3GenreRatings = await getBottom3GenreRatings();

      const ctx = document.getElementById('myChart').getContext('2d');
      const myChart = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: bottom3Genres,
          datasets: [{
            label: 'Top 3 Rated Genres',
            data: bottom3GenreRatings,
            backgroundColor: [
              'rgba(54, 162, 235, 0.2)'
            ],
            borderColor: [
              'rgb(54, 162, 235)'
            ],
            borderWidth: 1
          }]
        },
        options: {
          scales: {
            y: {
              min: 0,
              max: 10,
            }
          }
        }
      });
    }

    // returns array of clean data
    async function getData() {
      const response = await fetch('data/ratings.csv');
      const dataRaw = await response.text();

      // splitting data into rows, and removing column headers
      let data = dataRaw.split('\n').slice(1);

      // removing last row if empty
      if (data[data.length - 1] === '') {
        data.pop();
      }

      // splitting rows into columns
      for (let i = 0; i < data.length; i++) {
        let column = data[i];
        column = column.split(',');
        // concatenating title if commas are in it
        if (column[3].includes('"')) {
          column[3] = column[3].replace('"', '');
          column[3] += ",";

          let searchingEndQuotationMark = true;
          while (searchingEndQuotationMark) {
            if (column[4].includes('"')) {
              column[4] = column[4].replace('"', '');
              searchingEndQuotationMark = false;
            } else {
              column[4] += ",";
            }

            column[3] += column[4];
            column.splice(4, 1);
          }
        }
        data[i] = column;
      }

      // removing TV episodes, series, and shorts
      for (let i = 0; i < data.length; i++) {
        let column = data[i];

        if (column[5] != "movie") {
          data.splice(i, 1);
          i--;
        }
      }

      // concatenating genres into one sub-array
      for (let i = 0; i < data.length; i++) {
        let column = data[i];
        column[9] = [column[9]];
        if (column[9][0].includes('"')) {
          column[9][0] = column[9][0].replace('"', '');

          let searchingEndQuotationMark = true;
          while (searchingEndQuotationMark) {
            if (column[10].includes('"')) {
              column[10] = column[10].replace('"', '');
              searchingEndQuotationMark = false;
            }

            column[10] = column[10].replace(' ', '');
            column[9].push(column[10]);
            column.splice(10, 1);
          }
          data[i] = column;
        }
      }

      // removing documentaries
      for (let i = 0; i < data.length; i++) {
        let column = data[i];
        if (column[9].includes("Documentary")) {
          data.splice(i, 1);
        }
      } 

      // removing dateRated, URL, titleType, releaseDate
      for (let i = 0; i < data.length; i++) {
        let column = data[i];

        column.splice(2, 1); // dateRated
        column.splice(3, 1); // URL
        column.splice(3, 1); // titleType
        column.splice(8, 1); // releaseDate

        data[i] = column;
      }

      return data;
    }

    // returns array of titles
    async function getTitles() {
      const data = await getData();
      let titles = [];

      data.forEach(row => {
        titles.push(row[2])
      });

      return titles;
    }

    // returns array of ratings
    async function getRatings() {
      const data = await getData();
      let ratings = [];

      data.forEach(row => {
        ratings.push(row[1])
      })

      return ratings;
    }

    // returns array of genres (sorted alphabetically)
    async function getGenres() {
      const data = await getData();
      let genres = [];

      data.forEach(row => {
        for (let i = 0; i < row[6].length; i++) {
          if (!genres.includes(row[6][i])) {
            genres.push(row[6][i]);
          }
        }
      })
      
      genres = genres.sort();

      return genres;
    }

    // returns array of quantity of films per genre (sorted alphabetically)
    async function getQuantityGenres() {
      const data = await getData();
      const genres = await getGenres();

      let quantityGenres = [];

      for (let i = 0; i < genres.length; i++) {
        quantityGenres[i] = 0;
      }

      data.forEach(row => {
        for (let i = 0; i < row[6].length; i++) {
          let index = genres.indexOf(row[6][i]);
          quantityGenres[index] += 1;
        }
      })

      return quantityGenres;
    }

    // returns array of mean genre ratings (sorted alphabetically)
    async function getMeanGenreRatings() {
      const data = await getData();
      const genres = await getGenres();
      const quantityGenres = await getQuantityGenres();

      let meanGenreRatings = [];
      let sumGenres = [];

      // initialise arrays
      for (let i = 0; i < genres.length; i++) {
        meanGenreRatings[i] = 0;
        sumGenres[i] = 0;
      }

      data.forEach(row => {
        let rating = parseInt(row[1]);

        for (let i = 0; i < row[6].length; i++) {
          let index = genres.indexOf(row[6][i]);
          sumGenres[index] += rating;
        }
      })

      for (let i = 0; i < meanGenreRatings.length; i++) {
        meanGenreRatings[i] = Math.round((sumGenres[i] / quantityGenres[i]) * 10) / 10 ;
      }

      return meanGenreRatings;
    }

    // returns array of top 3 genre ratings (sorted descending)
    async function getTop3GenreRatings() {
      let meanGenreRatings = await getMeanGenreRatings();

      let top3GenreRatings = [];

      for (let i = 0; i < 3; i++) {
        let highestRating = meanGenreRatings[0];
        let highestRatingIndex = 0;

        for (let j = 1; j < meanGenreRatings.length; j++) {
          if (highestRating < meanGenreRatings[j]) {
            highestRating = meanGenreRatings[j];
            highestRatingIndex = j;
          }
        }
        top3GenreRatings.push(highestRating);
        meanGenreRatings.splice(highestRatingIndex, 1);
      }

      return top3GenreRatings;
    }

    // returns array of top 3 genres (sorted descending)
    async function getTop3Genres() {
      const top3GenreRatings = await getTop3GenreRatings();
      let genres = await getGenres();
      let meanGenreRatings = await getMeanGenreRatings();

      let top3Genres = [];
      let ratingIndex = 0;

      for (let i = 0; i < top3GenreRatings.length; i++) {
        let rating = top3GenreRatings[i];

        ratingIndex = meanGenreRatings.indexOf(rating);
        top3Genres.push(genres[ratingIndex]);
        genres.splice(ratingIndex, 1);
        meanGenreRatings.splice(ratingIndex, 1);
      }

      return top3Genres
    }

    // returns array of bottom 3 genre ratings (sorted descending)
    async function getBottom3GenreRatings() {
      let meanGenreRatings = await getMeanGenreRatings();

      let bottom3GenreRatings = [];

      for (let i = 0; i < 3; i++) {
        let lowestRating = meanGenreRatings[0];
        let lowestRatingIndex = 0;

        for (let j = 1; j < meanGenreRatings.length; j++) {
          if (lowestRating > meanGenreRatings[j]) {
            lowestRating = meanGenreRatings[j];
            lowestRatingIndex = j;
          }
        }
        bottom3GenreRatings.push(lowestRating);
        meanGenreRatings.splice(lowestRatingIndex, 1);
      }

      return bottom3GenreRatings;
    }

    // returns array of bottom 3 genres (sorted descending)
    async function getBottom3Genres() {
      const bottom3GenreRatings = await getBottom3GenreRatings();
      let genres = await getGenres();
      let meanGenreRatings = await getMeanGenreRatings();

      let bottom3Genres = [];
      let ratingIndex = 0;

      for (let i = 0; i < bottom3GenreRatings.length; i++) {
        let rating = bottom3GenreRatings[i];

        ratingIndex = meanGenreRatings.indexOf(rating);
        bottom3Genres.push(genres[ratingIndex]);
        genres.splice(ratingIndex, 1);
        meanGenreRatings.splice(ratingIndex, 1);
      }

      return bottom3Genres
    }

    // returns array of runtimes
    async function getRuntimes() {
      const data = await getData();
      let runtimes = [];

      data.forEach(row => {
        runtimes.push(row[4]);
      });

      return runtimes;
    }

    // returns array of number of imdb votes
    async function getImdbVotes() {
      const data = await getData();
      let imdbVotes = [];

      data.forEach(row => {
        imdbVotes.push(row[7]);
      });

      return imdbVotes;
    }

    // returns array of release years
    async function getYears() {
      const data = await getData();
      let years = [];

      data.forEach(row => {
        years.push(row[5]);
      });

      return years;
    }

    // returns array of imdb ratings
    async function getImdbRatings() {
      const data = await getData();
      let imdbRatings = [];

      data.forEach(row => {
        imdbRatings.push(row[3]);
      });

      return imdbRatings;
    }

    // 

  </script>
</body>

</html>
